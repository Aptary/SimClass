<!DOCTYPE html>
<html>
<head>
  <title>Encino Sim Class : Matrix Methods and the Wave Equation</title>

  <style type="text/css" title="currentStyle">
    @import "css/SimClass.css";
  </style>

<script src='http://processingjs.org/js/processing.min.js' type='text/javascript'/></script>
<!Install the MathJax stuff so we can show LaTeX>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/javascript"
  src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h2>The Wave Equation as a Linear System</h2>
In our
<a href="http://encinographic.blogspot.com/2013/05/simulation-class-wave-equation.html">
previous class</a>, 
we completed our exploration of higher-order explicit time-integration 
techniques, and moved from a simple spring system to a more complex 1-D Wave
Equation. Using the fourth-order Runge-Kutta (RK4) integration scheme, we
adapted our spring solver to the wave equation, which seemed stable at first, 
but as soon as we introduced external forces, the system showed immediate
instabilities.
<p>
The problem in our solution is related to how we calculated our fluid vertical
acceleration from the fluid's height. As a reminder, the 
<a href="https://en.wikipedia.org/wiki/Wave_equation">1D Wave Equation</a>
is written as:
<div class="LaTexEquation">
    \[
    \begin{equation}
    \frac{\partial^2 h}{\partial t^2} = c^2 \frac{\partial^2 h}{\partial x^2}
    \label{eq:Wave1D}
    \end{equation}
    \]
</div>
<p>
Where \(h\) represents height at a given location along an axis, and \(c^2\) 
represents the square of the wave propagation speed. I think this is my 
favorite equation, because of the implied equivalency of spatial and temporal
dimensions. It says that, as far as waves are concerned, space and time are
interchangeable (assuming you choose your units correctly). Anyway, let's
examine how we discretized this solution for a given point in our height array,
\(h_i\) and its acceleration \(a_i\).
<div class="LaTexEquation">
    \[
    \begin{equation}
    a_i = c^2 \frac{h_{i+1} -\ 2 h_i + \ h_{i-1}}{\Delta x^2}
    \label{eq:WaveDisc1}
    \end{equation}
    \]
</div>
The above equation, \(\eqref{eq:WaveDisc1}\) is just a discretization of 
Equation \(\eqref{eq:Wave1D}\) above, with
\(\frac{\partial^2 h}{\partial t^2}\) taken as acceleration. However, unlike the
simple spring system, where the position of the spring varied only in time,
our position varies in space as well, which means we have to consider that
every point in the array of heights depends on not only its previous positions
and velocities, but the heights and velocities and accelerations of neighboring
points. This was the oversimplification in our previous attempt, and the source
of the instability.
<p>
In order to understand this system better, let's replace the acceleration with
a finite difference approximation, based on the height and previous heights.
Starting with the backwards finite difference approximation of \(a_i\):
<div class="LaTexEquation">
    \[
    \begin{equation}
    a_{i_{t+\Delta t}} \approx \frac{h_{i_{t+\Delta t}} -
                                     \ 2 h_{i_{t}} +
                                     \ h_{i_{t-\Delta t}}}{\Delta t^2}
    \label{eq:FiniteDiffA}
    \end{equation}
    \]
</div>
we can follow the usual convention in height-field solvers, eliminating 
acceleration
by substituting Equation \(\eqref{eq:FiniteDiffA}\) into Equation
\(\eqref{eq:WaveDisc1}\) to get the following expression which contains
only height values (at different times and positions):

<div class="LaTexEquation">
    \[
    \begin{equation}
    \frac{h_{i_{t+\Delta t}} -
            \ 2 h_{i_{t}} +
            \ h_{i_{t-\Delta t}}}{\Delta t^2}
                                      =
    c^2 \frac{h_{{i+1}_{t+\Delta t}} - 
                \ 2 h_{i_{t+\Delta t}} + 
                \ h_{{i-1}_{t+\Delta t}} }
        {\Delta x^2}
    \label{eq:WaveHeightDisc1}
    \end{equation}
    \]
</div>

However, our RK4 solver and our other time-integration techniques were written
to employ a calculation of acceleration based on an estimate of current 
position and velocity, so it's more helpful if we instead begin with the
following <i>implicit</i> relationship between acceleration, velocity, and height:

<div class="LaTexEquation">
    \[
    \begin{equation}
    h_{i_{t+\Delta t}} = h_{i_t} + \Delta t\ v_{i_{t+\Delta t}} + 
        \Delta t^2\ a_{i_{t+\Delta t}}
    \label{eq:ImplicitHeightTimeStep}
    \end{equation}
    \]
</div>

Let's treat the first two terms of the right hand side of Equation 
\(\eqref{eq:ImplicitHeightTimeStep}\) as an 
<i>estimate</i> of height at time \(t+\Delta t\), denoted by \(h^\star\),
indicated as follows:

<div class="LaTexEquation">
    \[
    \begin{equation}
    h^\star_{i_{t+\Delta t}} = h_{i_t} + \Delta t\ v_{i_{t+\Delta t}}
    \label{eq:HeightEstimate}
    \end{equation}
    \]
</div>

And then we can substitute Equation \(\eqref{eq:HeightEstimate}\) into
Equation \(\eqref{eq:ImplicitHeightTimeStep}\) to get:

<div class="LaTexEquation">
    \[
    \begin{equation}
    h_{i_{t+\Delta t}} = h^\star_{i_{t+\Delta t}} + 
        \Delta t^2\ a_{i_{t+\Delta t}}
    \label{eq:EstimatedHeightTimeStep}
    \end{equation}
    \]
</div>

Now, we can subsitute Equation \(\eqref{eq:EstimatedHeightTimeStep}\) into
Equation \(\eqref{eq:WaveDisc1}\) to get the following equation, written
in terms of the current acceleration and an <i>estimate</i> of the current
height. 

<div class="LaTexEquation">
    \[
    \begin{equation}
    a_{i_{t+\Delta t}} = 
    c^2 \frac{h^\star_{{i+1}_{t+\Delta t}} - 
                \ 2 h^\star_{i_{t+\Delta t}} + 
                \ h^\star_{{i-1}_{t+\Delta t}} }
        {\Delta x^2} +
    c^2 \Delta t^2
        \frac{a_{{i+1}_{t+\Delta t}} - 
                \ 2 a_{i_{t+\Delta t}} + 
                \ a_{{i-1}_{t+\Delta t}} }
        {\Delta x^2}
    \label{eq:AccelDisc1Subscripted}
    \end{equation}
    \]
</div>

All of the terms in Equation \(\eqref{eq:AccelDisc1Subscripted}\) are at the
same point in time, so we can drop the time subscript. Assuming that the 
estimates of height are given by some process (which we are free to tinker with),
the equation is a linear relationship between accelerations at different points 
in space. Let's 
simplify by defining intermediate constants:

<div class="LaTexEquation">
    \[
    \begin{equation}
    \kappa = \frac{c^2 \Delta t^2}{\Delta x^2},
    \ \gamma = \frac{c^2}{\Delta x^2} 
    \label{eq:Constants}
    \end{equation}
    \]
</div>

Substituting in our constants, moving all of the acceleration terms to the
left-hand side, and gathering coefficients, we have the following equation
which expresses the relationship between the acceleration at the index \(i\) 
and its spatially adjacent neighbors:

<div class="LaTexEquation">
    \[
    \begin{equation}
    (1 + 2 \kappa) a_i +
    ( -\kappa ) a_{i-1} +
    ( -\kappa ) a_{i+1} =
    \gamma ( h^\star_{i+1} - 
                \ 2 h^\star_i + 
                \ h^\star_{i-1} )
    \label{eq:AccelOneMatrixRow}
    \end{equation}
    \]
</div>

The above Equation \(\eqref{eq:AccelOneMatrixRow}\) is written relative to
any position in the array of heights, denoted by the subscript variable \(i\),
and this relationship exists at each point in the array. 
We'll next write out the equations at each index explicitly, to get a system of 
linear equations. We have to take a bit of care at the boundary points.
Our boundary condition
is that heights at the boundary are equal to the height at the adjacent,
non-boundary position, which, when transformed to a boundary condition on 
acceleration, says that the acceleration at the boundary is zero. Therefore, we
have no equation for index i = 0 and index i = ArraySize-1, because we've
explicitly defined those points. Furthermore, for points i = 1 and i = ArraySize-2,
the relationship is slightly changed, which we'll incorporate into the
equations.  

<div class="LaTexEquation">
    \[
    \begin{eqnarray*}

                \  &\ & (1+2\kappa)a_1& +& (-\kappa)a_2& =& 
        \gamma ( h^\star_0 - 2 h^\star_1 + h^\star_2 ) \\

    (-\kappa)a_1& +& (1+2\kappa)a_2& +& (-\kappa)a_3& =& 
        \gamma ( h^\star_1 - 2 h^\star_2 + h^\star_3 ) \\

    (-\kappa)a_2& +& (1+2\kappa)a_3& +& (-\kappa)a_4& =& 
        \gamma ( h^\star_2 - 2 h^\star_3 + h^\star_4 ) \\

    ... \\

    (-\kappa)a_{n-5}& +& (1+2\kappa)a_{n-4}& +& (-\kappa)a_{n-3}& =& 
        \gamma ( h^\star_{n-5} - 2 h^\star_{n-4} + h^\star_{n-3} ) \\

    (-\kappa)a_{n-4}& +& (1+2\kappa)a_{n-3}& +& (-\kappa)a_{n-2}& =& 
        \gamma ( h^\star_{n-4} - 2 h^\star_{n-3} + h^\star_{n-2} ) \\

    (-\kappa)a_{n-3}& +& (1+2\kappa)a_{n-2}&\ &\ & =& 
        \gamma ( h^\star_{n-3} - 2 h^\star_{n-2} + h^\star_{n-1} ) \\
        

    \label{eq:AccelLinearSystem}
    \end{eqnarray*}
    \]
</div>

Equation \(\eqref{eq:AccelLinearSystem}\).

This above system of linear equations can be expressed as a sparse matrix
equation:
<div class="LaTexEquation">
    \[
    \begin{equation}
    A x = b
    \end{equation}
    \]
</div>
Where the sparse, symmetric matrix \(A\) is defined as:
<div class="LaTexEquation">
\[
\begin{equation}
A =
 \begin{bmatrix}
  1+2\kappa & -\kappa    & \         & \         & \         & \         & \cdots    \\
  -\kappa   & 1+2\kappa  & -\kappa   & \         & \         & \         & \cdots    \\
  \         & -\kappa    & 1+2\kappa & -\kappa   & \         & \         & \cdots    \\
  \ \vdots  & \          & \ddots    & \ddots    & \ddots    & \         & \cdots    \\
  \ \cdots  & \          & \         & -\kappa   & 1+2\kappa & -\kappa   & \         \\
  \ \cdots  & \          & \         & \         & -\kappa   & 1+2\kappa & -\kappa   \\
  \ \cdots  & \          & \         & \         & \         & -\kappa   & 1+2\kappa \\
 \end{bmatrix}
 \end{equation}
 \]
</div>
and the column vectors \(x\) and \(b\) are defined as:
<div class="LaTexEquation">
\[
\begin{equation}
x =
 \begin{bmatrix}
  a_1 \\
  a_2 \\
  a_3 \\
  \vdots \\
  a_{n-4} \\
  a_{n-3} \\
  a_{n-2} \\
 \end{bmatrix}
 ,
b =
 \begin{bmatrix}
  \gamma ( h^\star_0 - 2 h^\star_1 + h^\star_2 ) \\
  \gamma ( h^\star_1 - 2 h^\star_2 + h^\star_3 ) \\
  \gamma ( h^\star_2 - 2 h^\star_3 + h^\star_4 ) \\
  \vdots \\
  \gamma ( h^\star_{n-5} - 2 h^\star_{n-4} + h^\star_{n-3} ) \\
  \gamma ( h^\star_{n-4} - 2 h^\star_{n-3} + h^\star_{n-2} ) \\
  \gamma ( h^\star_{n-3} - 2 h^\star_{n-2} + h^\star_{n-1} ) \\
 \end{bmatrix}
 \end{equation}
 \]
</div>
We have thus transformed our acceleration computation problem into
an \(A x = b\) matrix problem, a problem which has been carefully studied,
and for which many extremely well-understood methods of solution exist.

<p>
That's not bad! Perhaps we could make it more interesting, by gathering
some mouse input. We'll make it so that if you click in the view, it will
set the height and velocity of the sim at that point to the height of the click,
and zero, respectively. The input grabbing code looks like this:
<p>
<pre><code>
void GetInput()
{
    if ( mousePressed && mouseButton == LEFT )
    {
        float mouseCellX = mouseX / ( ( float )PixelsPerCell );
        float mouseCellY = ( (height/2) - mouseY ) / ( ( float )PixelsPerCell );
        float simY = mouseCellY * DX;
        
        int iX = ( int )floor( mouseCellX + 0.5 );
        if ( iX > 0 && iX < ArraySize-1 )
        {
            State[StateHeight][iX] = simY;
            State[StateVel][iX] = 0.0;
        }
    }
}
</code></pre>
<p>
And we just add that directly into our main draw loop, right before the 
time step:
<p>
<pre><code>
void draw()
{
    background( 0.9 );
   
    GetInput();
   
    TimeStep( 1.0 / 24.0 );

    // Label.
    fill( 1.0 );
    text( "Wave Equation RK4", 10, 30 );
  
    DrawState();
}
</code></pre>
<p>
And what happens now? Here it is running:
<p>
<script type="application/processing" data-processing-target="pjsWaveEqnRK4_WithInput">
float WaveSpeed = 0.5;

float WorldSize = 10.0;
int ArraySize = 128;
float DX = WorldSize / ArraySize;

float LX = WorldSize;
float LY = WorldSize / 2.0;

int StateSize = 7;
float[][] State = new float[StateSize][ArraySize];
int StateHeight = 0;
int StateVel = 1;
int StateHeightPrev = 2;
int StateVelPrev = 3;
int StateVelStar = 4;
int StateAccelStar = 5;
int StateHeightTmp = 6;

float StateCurrentTime = 0.0;

int PixelsPerCell = 4;

int WindowWidth = PixelsPerCell * ArraySize;
int WindowHeight = WindowWidth / 2;

float snoise( float x )
{
   return ( 2.0 * noise( x )) - 1.0;
}

float anoise( float x )
{
   return ( -2.0 * abs( snoise( x )) ) + 1.0;
}

void EnforceBoundaryConditions( int io_a )
{
    State[io_a][0] = State[io_a][1];
    State[io_a][ArraySize-1] = State[io_a][ArraySize-2];
}

void SetInitialState()
{
    noiseSeed( 0 );
    for ( int i = 0; i < ArraySize; ++i )
    {
        float worldX = 2341.17 + DX * ( float )i;
        State[StateHeight][i] = 0.5 * anoise( worldX * 0.0625 ) +
                         0.4 * anoise( worldX * 0.125 ) +
                         0.3 * anoise( worldX * 0.25 ) +
                         0.2 * anoise( worldX * 0.5 );
        State[StateVel][i] = 0.0;
    }
    EnforceBoundaryConditions( StateHeight );
    EnforceBoundaryConditions( StateVel );
    StateCurrentTime = 0.0;
}

void setup()
{
    SetInitialState();
    
    size( WindowWidth, WindowHeight );
    
    colorMode( RGB, 1.0 );
    strokeWeight( 0.5 );
    textSize( 24 );
}

void SwapHeight()
{
    int tmp = StateHeight;
    StateHeight = StateHeightPrev;
    StateHeightPrev = tmp;
}

void SwapVel()
{
    int tmp = StateVel;
    StateVel = StateVelPrev;
    StateVelPrev = tmp;
}

void SwapState()
{
    SwapHeight();
    SwapVel();
}

void CopyArray( int i_src, int o_dst )
{
    for ( int i = 0; i < ArraySize; ++i )
    {
        State[o_dst][i] = State[i_src][i];
    }
}

void GetInput()
{
    if ( mousePressed && mouseButton == LEFT )
    {
        float mouseCellX = mouseX / ( ( float )PixelsPerCell );
        float mouseCellY = ( (height/2) - mouseY ) / ( ( float )PixelsPerCell );
        float simY = mouseCellY * DX;
        
        int iX = ( int )floor( mouseCellX + 0.5 );
        if ( iX > 0 && iX < ArraySize-1 )
        {
            State[StateHeight][iX] = simY;
            State[StateVel][iX] = 0.0;
        }
    }
}

void A_from_H( int i_h )
{
    for ( int i = 1; i < ArraySize-1; ++i )
    {
        float hLeft = State[i_h][i-1];
        float hCen = State[i_h][i];
        float hRight = State[i_h][i+1];

        float d2h_dx2 = ( hRight + hLeft - ( 2.0*hCen ) ) / sq( DX );

        State[StateAccelStar][i] = sq( WaveSpeed ) * d2h_dx2;
    }
    
    EnforceBoundaryConditions( StateAccelStar );
}

// Estimate temp height
void EstimateTempHeight( float i_dt )
{
    for ( int i = 0; i < ArraySize; ++i )
    {
        State[StateHeightTmp][i] = State[StateHeightPrev][i] + 
                ( i_dt * State[StateVelStar][i] );
    }
    EnforceBoundaryConditions( StateHeightTmp );
}

// Estimate vel star
void EstimateVelStar( float i_dt )
{
    for ( int i = 0; i < ArraySize; ++i )
    {
        State[StateVelStar][i] = State[StateVelPrev][i] + 
                ( i_dt * State[StateAccelStar][i] );
    }
    EnforceBoundaryConditions( StateVelStar );
}

// Accumulate estimate
void AccumulateEstimate( float i_dt )
{
    for ( int i = 0; i < ArraySize; ++i )
    {
        State[StateHeight][i] += i_dt * State[StateVelStar][i];
        State[StateVel][i] += i_dt * State[StateAccelStar][i];
    }
}

// Acceleration from height. This uses the spatial second derivative.
// Note that we're iterating only over the central points, not the edges,
// which are handled by the boundary condition.
void A_from_H( int i_h )
{
    for ( int i = 1; i < ArraySize-1; ++i )
    {
        float hLeft = State[i_h][i-1];
        float hCen = State[i_h][i];
        float hRight = State[i_h][i+1];

        float d2h_dx2 = ( hRight + hLeft - ( 2.0*hCen ) ) / sq( DX );

        State[StateAccelStar][i] = sq( WaveSpeed ) * d2h_dx2;
    }
    
    EnforceBoundaryConditions( StateAccelStar );
}

// Time Step function.
void TimeStep( float i_dt )
{
    // Swap state
    SwapState();
    
    // Initialize estimate. This just amounts to copying
    // The previous values into the current values.
    CopyArray( StateHeightPrev, StateHeight );
    CopyArray( StateVelPrev, StateVel );
    
    // Vstar1, Astar1
    CopyArray( StateVel, StateVelStar );
    A_from_H( StateHeight );
    // Accumulate
    AccumulateEstimate( i_dt / 6.0 );
    
    // Height Temp 2
    EstimateTempHeight( i_dt / 2.0 );
    // Vstar2, Astar2
    EstimateVelStar( i_dt / 2.0 );
    A_from_H( StateHeightTmp );
    // Accumulate
    AccumulateEstimate( i_dt / 3.0 );
    
    // Height Temp 3
    EstimateTempHeight( i_dt / 2.0 );
    // Vstar3, Astar3
    EstimateVelStar( i_dt / 2.0 );
    A_from_H( StateHeightTmp );
    // Accumulate
    AccumulateEstimate( i_dt / 3.0 );
    
     // Height Temp 4
    EstimateTempHeight( i_dt );
    // Vstar3, Astar3
    EstimateVelStar( i_dt );
    A_from_H( StateHeightTmp );
    // Accumulate
    AccumulateEstimate( i_dt / 6.0 );
    
    // Final boundary conditions on height and vel
    EnforceBoundaryConditions( StateHeight );
    EnforceBoundaryConditions( StateVel );

    // Update current time.
    StateCurrentTime += i_dt;
}

void DrawState()
{
    float OffsetY = 0.5 * ( float )WindowHeight;
    for ( int i = 0; i < ArraySize; ++i )
    {
        float SimX = DX *  ( float )i;
        float PixelsX = ( float )( i * PixelsPerCell );
        float SimY = State[StateHeight][i];
        float PixelsY = SimY * (( float )PixelsPerCell ) / DX;
        float PixelsMinY = OffsetY - PixelsY;
        float PixelsHeight = (( float )WindowHeight) - PixelsMinY;

        fill( 0.0, 0.0, 1.0 );   
        rect( PixelsX, OffsetY - PixelsY, PixelsPerCell, PixelsHeight );
    }
}

void draw()
{
    background( 0.9 );
   
    GetInput();
   
    TimeStep( 1.0 / 24.0 );

    DrawState();
    
    // Label.
    fill( 1.0 );
    text( "Wave Equation RK4 - With Input", 10, 30 );
}

// Reset function. If the key 'r' is released in the display, 
// copy the initial state to the state.
void keyReleased()
{
    if ( key == 114 )
    {
        SetInitialState();
    }  
}

</script>
<canvas id="pjsWaveEqnRK4_WithInput"> </canvas>
<p>
Uh oh.... Looks like stability has eluded us again. Next class, we'll look
into how to fix stability for cases like this, involving multiple derivatives.

</body>
